:domain
Aggregates, VOs, domain services, repository interfaces, domain events, etc.
Does not know about pagination types directly (or only uses them if you treat them as shared-kernel).

:application (or :core if you merge application+domain)
Application services / use cases.
Query/filter objects (CustomerFilter, etc.).
PageRequest, PageResult, SortOrder, SortDirection live here.

Why? Pagination is typically about how you call use cases, not pure domain behavior.

:adapter-persistence-jpa
JPA entities, Spring Data repositories.
Adapters that do PageRequest -> Pageable and Page<CustomerEntity> -> PageResult<Customer>.

:adapter-rest-api
Controllers.
Request/response DTOs.
PageResponse lives here.

:bootstrap
@SpringBootApplication class.
Wiring of modules (depends on all adapters + application).


*** why keep rest-api as separate module and not merge with application level
Keeps your core logic testable without pulling in spring-boot-starter-web.
Lets you potentially add other adapters later (gRPC, Kafka consumers, CLI) without bloating your web module.

:domain                  (no deps)
:application   -> :domain
:adapter-persistence-jpa -> :application, :domain
:adapter-rest-api        -> :application, :domain (and possibly :shared if you split it)
:adapter-messaging       -> :application, :domain
:infrastructure-external // external APIs, etc (later)

:bootstrap               -> everything


1. What hexagonal / DDD actually cares about
Hexagonal (ports & adapters) + DDD basically says:

*Core
Domain model (domain)
Application services / use cases (application)

*Edges (adapters)
Driving adapters (things that call your app): REST, GraphQL, CLI, messaging consumers
Driven adapters (things your app calls): DB, message broker, external APIs, file storage, etc.

It does not mandate folder/module names. It only cares about dependency direction and separation of concerns.






it is common to join application with domain and call it core in hex architecture.

***Eric Evans’ DDD book shows a 4-layer architecture:
User Interface / Presentation
Application
Domain
Infrastructure


***DDD layers:
domain
application
presentation
infrastructure

***Hexagonal concepts inside those:
CustomerRepository = port (in domain)
CustomerRepositoryJpaAdapter = adapter (in infrastructure.persistence)
CustomerQueryService = application port (in application)
CustomerController = adapter (in presentation)



#######
## Architecture Overview

This project uses **Domain-Driven Design (DDD)** and **Hexagonal Architecture (Ports & Adapters)**.

### DDD in this project

DDD splits the code by *responsibility*, not by technology:

- **Domain layer** – the heart of the system
  - Contains the business model: aggregates, entities, value objects, domain services.
  - Expresses business rules and invariants in ubiquitous language.
  - Has no idea about HTTP, databases, or frameworks.

- **Application layer** – use cases / workflows
  - Coordinates domain objects to implement use cases (e.g. *Search customers*, *Place order*).
  - Defines transaction boundaries and high-level policies (authorization, events, etc.).
  - Calls domain repositories and other ports, but does not contain low-level technical code.

- **Presentation layer** – how the outside world talks to us
  - HTTP/REST controllers, request/response DTOs, validation.
  - Translates HTTP/JSON into application-level inputs and back into HTTP responses.

- **Infrastructure layer** – technical details
  - Database mappings (JPA entities), Spring Data repositories, external API clients, messaging, etc.
  - Implements ports defined by domain/application.

### Hexagonal Architecture (Ports & Adapters)

Hexagonal architecture describes **how** layers connect:

- **Ports** – interfaces that define what the core needs or exposes.
  - Incoming ports: application services (use cases) called by controllers, CLI, batch jobs, etc.
  - Outgoing ports: repositories, external service clients, message publishers, etc.

- **Adapters** – implementations of ports at the edges.
  - Driving adapters: REST controllers, CLI, schedulers (they *call into* application services).
  - Driven adapters: JPA adapters, HTTP clients, Kafka producers (they are *called by* the core).

The core (domain + application) does not depend on any specific framework or transport.
Adapters depend on the core, never the other way around.

---

## Modules

### `:shared-kernel`

**Responsibility**

- Very small module for **generic, stable types** shared across layers.
- Contains things that are not specific to a single bounded context.

**Typical contents**

- Pagination primitives: `PageCriteria`, `PageResult`, `SortOrder`, `SortDirection`.
- Cross-cutting value objects (if needed): IDs, Money, etc.

**Dependencies**

- Has **no** dependency on other project modules.
- Other modules (`:core`, adapters) may depend on `:shared-kernel`.

---

### `:core` (Domain + Application)

This module contains the **business core** of the system: domain model + use cases.

#### Domain (package `core.domain.*`)

**Responsibility**

- Model the business with rich types and rules.
- Provide aggregates, entities, value objects, and domain services.
- Define **domain repositories** as interfaces (ports) for persistence.

(A Value Object is an immutable object that describes some characteristic or attribute but has no identity of its own. It's defined by its values, not by a unique ID.)
1. Equality by Value (not by identity)
2. Immutable (cannot be changed after creation)
3. Self-Validating (always in a valid state)
4. No Identity (no ID field)

When to Use Value Objects
1. Type represents a concept with validation rules
- Email, Phone, ZipCode, SSN
2. Type has business meaning beyond primitive
- Money (amount + currency), Address (structured), DateRange
3. Type should be immutable
- Coordinates, Temperature, Color
4. Type has no identity
- Two emails with same value are "the same email"

❌ Don't Use Value Objects When:
1. Simple primitive is sufficient
- name: String (if no validation needed)
2. Object needs identity
- User, Order, Product (use Entity)
3. Object changes frequently
- Shopping cart (use Entity with mutable state)

Benefits of Value Objects
1. Type Safety
2. Validation in One Place
3. Business Rules Encapsulation
4. Prevents Primitive Obsession Anti-Pattern

Value Objects move validation and business rules from everywhere in your code into one place - the constructor. Once created, they're guaranteed to be valid.


Why it's an Entity:
- Has unique identity: Uses PatientId to uniquely identify each patient
- Identity persists: A patient with ID "123" remains the same patient even if their email or name changes
- Mutable state: Can change email, name, address through domain methods
- Equality based on identity: The equals() method compares based on id, not attributes

Why it's an Aggregate Root:

- Entry point for operations: All modifications go through the Patient class methods
- Manages domain events: Collects and publishes events for state changes
- Enforces business invariants: Validates email uniqueness, name constraints, etc.
- Contains value objects: Manages Email, Address, and previously Name value objects
- Transactional boundary: All changes to patient-related data go through this root



**Typical contents**

- `core.domain.customer.Customer`, `CustomerId`, `CustomerSearchCriteria`
- `core.domain.customer.CustomerRepository` (domain port)
- Domain logic methods like `order.cancel()`, `customer.changeEmail()`, etc.
- Pure domain services that may depend on repositories.

**Dependencies**

- Depends only on `:shared-kernel` (for generic types like pagination, IDs, etc.).
- Does **not** depend on application, presentation, or infrastructure.

#### Application (package `core.application.*`)

**Responsibility**

- Implement **use cases** by orchestrating domain objects and repositories.
- Define application-level input/output models (commands, filters, summaries).
- Define and implement application services (incoming ports) used by adapters.
- Handle transactions, use-case-level authorization and high-level policies.

**Typical contents**

- `core.application.customer.CustomerFilter`, `CustomerSummary`
- `core.application.customer.CustomerQueryService`, `CustomerQueryServiceImpl`
- Mapping between domain types and application DTOs.
- Publishing domain events via outgoing ports.

**Dependencies**

- Depends on `core.domain.*` and `:shared-kernel`.
- Does **not** depend on presentation or infrastructure.

---

### `:adapter-rest`

**Responsibility**

- Expose the application layer via **HTTP/REST**.
- Translate HTTP requests into application calls and map results to JSON responses.

**Typical contents**

- Controllers: `CustomerController` (driving adapters).
- Web DTOs:
  - Requests: `CustomerSearchRequest`, other request bodies.
  - Responses: `CustomerResponse`, `PageResponse`, etc.
- Web mappers:
  - `CustomerWebMapper` (maps `CustomerSearchRequest` → `CustomerFilter`, `CustomerSummary` → `CustomerResponse`).
- Extension functions for mapping pagination:
  - `PageResult<T>.toPageResponse(...)` in `presentation/common`.

**Dependencies**

- Depends on `:core` (application + domain) and `:shared-kernel`.
- Does **not** contain business rules or persistence logic.

---

### `:adapter-persistence-jpa`

**Responsibility**

- Provide a JPA-based implementation of domain repositories.
- Translate between domain entities and database representation.

**Typical contents**

- JPA entities: `CustomerEntity`, etc.
- Spring Data interfaces: `SpringDataCustomerRepository`.
- Adapters implementing domain repository ports:
  - `CustomerRepositoryJpaAdapter : CustomerRepository`
- Mappers between JPA entities and domain aggregates:
  - `CustomerPersistenceMapper`.

**Dependencies**

- Depends on `:core` (to implement `CustomerRepository` and map to domain types).
- Depends on JPA/Spring Data and the database driver.
- Does **not** depend on `:adapter-rest`.

---

### `:bootstrap`

**Responsibility**

- Application startup and wiring.
- Contains the `@SpringBootApplication` entrypoint and configuration that ties modules together.

**Typical contents**

- `ApiApplication.kt` (main method).
- Spring configuration for component scanning, profiles, etc.

**Dependencies**

- Depends on `:core`, `:adapter-rest`, `:adapter-persistence-jpa`, and possibly other adapters.
- Contains **no** business logic.

---

### Dependency Direction Summary

```text
              +---------------------+
              |     :shared-kernel  |
              +----------+----------+
                         ^
                         |
               +---------+----------+
               |        :core       |  (domain + application)
               +----+----------+----+
                    ^          ^
                    |          |
          +---------+--+    +--+----------------+
          | :adapter-rest |  | :adapter-persistence-jpa |
          +---------+-----+  +-----------+-------------+
                    ^                      ^
                    |                      |
                    +-----------+----------+
                                |
                           :bootstrap


